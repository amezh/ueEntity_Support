[{"name":"ueEntity","description":"general description","path":"/ueentity","text":"","wordCount":0,"type":"TOC"},{"name":"Releases","description":"recent releases and notes","path":"/ueentity/releases","text":"","wordCount":0,"type":"Content"},{"name":"Getting Started","description":"quick guide to setup a scene","path":"/ueentity/gettingstarted","text":"","wordCount":0,"type":"Content"},{"name":"Plugin Documentation","description":"Entities, Components, Systems","path":"/ueentity/docs","text":"","wordCount":0,"type":"TOC"},{"name":"Entities","description":"Everything about Entities","path":"/ueentity/docs/entities","text":"Introduction\nEntity in context of ueEntity is just an integer id.\nManipulating entities is easy and fast.\nTo do that we use USceneComponent: EntityRegistryContainer.\nAttach it to any actor to spawn.\nTo create and destroy an Entity do one of the following:\nFrom C++\n`C++\nint CreateEntity();\nvoid DeleteEntity(int entityId);\n`\nFrom BP:\nalt text","wordCount":43,"type":"Content"},{"name":"Components","description":"Everything about Components","path":"/ueentity/docs/components","text":"Components\nComponents are C++ structs and they ment to act as a data storage, so no logic is allowed here.\nThere are 2 main types of components in the plugin:\nCustom Components - think of them like property bags for entities.\nBuiltin Components  - Pre-defined C++ structs\nWe'll talk about pre-defined components in detail in sections below, for now here is the list:\nTransform\nRender\nAnimation\nYep, that's it.","wordCount":60,"type":"Content"},{"name":"TransformComponent","description":"Position Rotation Scale","path":"/ueentity/docs/components/transform","text":"Transform Component\nTransform component is a storage for entity Transform\nIt's also very important part of a plugin infrastructure.\nIt's a dependancy for Rendering component and Transform Animation components family.\nRemoving the component from entity will result in removal of Rendering and Animation compoments as well since we can't render or transform anything without their transform storage.\nIt contains two fields\nFTransform transform; -  this is BP exposed transform itself\nbool isDirty; - managed internaly by aanimation and rendering systems.\n>WARNING: if you ever change it by ref from C++ make sure to mark it Dirty as well or rendering system will ignore it\nmanipulating the component is simple:\nC++\n`C++\nbool GetTransformComponent(int entityId, FTransformComponent& valueOut);\nbool SetTransformComponent(int entityId, FTransformComponent value);\nvoid DeleteTransformComponent(int entityId);\n`\nBP:\nalt text","wordCount":111,"type":"Content"},{"name":"RenderComponent","description":"What and where to render","path":"/ueentity/docs/components/render","text":"Render Component\nRender component works with InstancedStaticMesh(ISM) or HierarchicalInstancedStaticMesh\nComponent is quite simple and consists from two fields:\nUInstancedStaticMeshComponent* meshComponent - a ref to component itself\nint instanceId - a copy of assigned InstanceID in the ISM above. This property is not exposed to BP since rendering system will manage it for you.\nRender Components can be assigned to any Entity at any time and removed in any time. Entity will keep animating even if it's not rendering anymore.\nRendering system will be notified any time any Rendering component assigned or destroyed and will manage instances according to the situation.\nEntity can travel frely across the ISMs. Just remove one component and assign another one.\nFor example if your apple tree grew big enough and you want to swap it to another model - you can do that.\nOr if you have an unloaded truck and you want to change the model to loaded one - create two ISMs and travel your entity between them.\nYou can control Rendering mesh with the following:\nC++:\n`C++\nbool GetRendererComponent(int entityId, FRenderComponent& valueOut);\nbool SetRendererComponent(int entityId, FRenderComponent value);\nvoid DeleteRendererComponent(int entityId);\n`\nBP\nalt text","wordCount":174,"type":"Content"},{"name":"AnimationComponent","description":"Actually a few animation compoments","path":"/ueentity/docs/components/Animation","text":"","wordCount":0,"type":"Content"},{"name":"CustomComponent","description":"aka whatever you want","path":"/ueentity/docs/components/CustomComponent","text":"Custom Component\nIntroduction\nCreating bag and component\nModifying fields\nIntroduction\nSince in C++ we can't create classes in runtime and we want to be able to manipulate data from BP - we invented Custom component\nIt's basically a named list of components attached to your Entity in a bag (aka FBagComponent).\nTo make it look like a structure we are grouping fields in a bag as \"Components\"\nEach entity has it's own bag.\nEach component has a name and it's own set of fields\nTo visualize it looks like this:\nalt text\nLooks heavy for performance but in reality it's not bad at all. More info on performance in section: System\nBag and component\nWith bag - it's simple, you don't have to worry about them at all. We'll create them as needed and delete from memory with Entity.\nComponents on the other hand are a bit more tricky.\nThere are 3 ways to do that:\nalt text\n1. You create empty component with no pre-defined fields. Whenever you will do SetValue we'll create a field on the fly if it's not there.\n2. Option 2 is to create component structure from existing BP structure, we'll cache it for future uses and you can attach it to any or all the entities you need.\n3. We can create component from existing structure and copy all the values to fields. However while convinient this is a very slow operation and will kill performance for you if done inside the system loop (well maybe if you do it for like 100 entities it will be alright) but seriously, use on your own risk.\nFields\nWe have our component how do we Get\\Set field? And what type of fields are supported out of the box?\nLet's take a look.\nSince components are structs and you're not allowed to use UFUNCTION in structs and since we are not blessed with wildcard blueprint output nodes for value types we have a BP Function library with a bunch of setters and getters:\nalt text\nFrom C++ they are all static functions of UComponentFunctions\nSupported types are:\nint\nfloat\nFText\nFString\nFName\nbool\nFVector\nFEntityComponent - for nested stuctures\nIn reality components will support any type you want. Just not everything has Get and Set fields exposed. if you look on implementation, get and set values are templated.\nSo even if you're not very good with C++, copy code below into your own C++ Blueprint Function Library and add whatever types you need between\n`C++\nstatic bool GetValueInt(UPARAM(ref) FEntityComponent& Component, FString fieldName, int& valueOut)\n{\n    return Component.GetFieldValue(fieldName, valueOut);\n};\nstatic bool SetValueInt(UPARAM(ref) FEntityComponent& Component, FString fieldName, int value)\n{\n    return Component.SetFieldValue(fieldName, value);\n};\n`\nif you have a reference to the Bag  (which you will in systems loop functions), you may also use GetCustomComponent function from the same BP library to get your component by name.","wordCount":432,"type":"Content"},{"name":"Systems","description":"Everything about Systems","path":"/ueentity/docs/systems","text":"Systems","wordCount":1,"type":"Content"},{"name":"FAQs","description":"frequently asked questions are covered here","path":"/ueentity/faq","text":"This content is refreshed as new features and functions are introduced, or existing functions evolve.  Check back often!\nIntroduction\nHow to create a new Page on the Playbook?\nHow to write a document in Markdown?\nIntroduction\nhere is some Introduction text...\nHow to create a new Page on the Playbook?\n... use the pageConfig.json and create a new Page document.\nHow to create a new Page on the Playbook?\nCheckout the Markdown Cheat Sheet https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet","wordCount":66,"type":"Content"}]